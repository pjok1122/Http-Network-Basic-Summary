# Http-Network-Basic-Summary

우에노 센 저자님의 '그림으로 배우는 Http&amp;Network Basic' 책 요약 내용입니다.

## [1장. 웹과 네트워크의 기본에 대해 알아보자.]

- HTTP 프로토콜은 세계 각지에서 지식을 공유하기 위해 생겨났습니다.

- 네트워크는 계층을 나누어 관리하는데, 그 이유는 특정 계층의 사양이 변경되었을 때 모든 프로토콜을 변경하지 않도록 하기 위함입니다.

- 데이터를 전송하기 위해서는 네트워크 각 계층에서 헤더를 붙여 아래 계층으로 전달하는 `캡슐화` 라는 작업을 진행합니다.

- IP통신은 사실 MAC주소를 가지고 통신을 합니다. MAC 주소란 네트워크 카드에 할당된 고유한 주소입니다. MAC주소는 `ARP(Address Resolution Protocol)`에 의해 `IP-to-MAC`으로 변환됩니다.

- TCP는 신뢰성있는 데이터를 전송에 대한 프로토콜입니다. 신뢰를 위해 `3-way handshake`, `흐름제어`, `혼잡제어`와 같은 작업을 수행합니다.

- `DNS(Domain Name Server)`는 도메인(URL)을 IP주소로 변환해주는 서비스를 제공하는 애플리케이션 계층에 속합니다.

- `URL(Uniform Resource Locator)`은 웹 페이지를 표시하기 위해 입력하는 주소를 의미합니다.

- `URI(Uniform Resource Identifier)`는 리소스를 구별하는 식별자가 존재하는 문자열입니다.
  - `ftp://ffp.is.co.za/rfc/rfc1808.txt`
  - `tel:+1-816-555-1212`
  - `news:comp.infosystems.www.servers.unix`
  - `http://www.ietf.org/rfc/rfc23969.txt` (URL)

<hr>

## [2장. 간단한 프로토콜 HTTP]

- HTTP는 서버와 클라이언트 간의 통신에 대한 약속입니다. 리소스를 요청하는 쪽을 클라이언트, 리소스를 제공하는 쪽을 서버라고 지칭합니다.

- HTTP는 상태를 유지하지 않는 프로토콜입니다. 따라서 `쿠키와 세션`을 이용해 이전에 통신했던 데이터를 기억하는 방식을 사용합니다.

  - 쿠키는 서버가 클라이언트에게 최초로 제공하고, 클라이언트는 이후 리퀘스트를 요청할 때 헤더에 쿠키를 포함하여 함께 전달합니다.

- 서버의 리소스는 리퀘스트 URI로 식별합니다.

- 서버의 동작은 리퀘스트의 `Method` 부분을 통해 결정됩니다.

  - GET : 서버의 리소스를 획득
  - POST : 서버의 리소스에 엔티티를 전달 (리소스의 값을 변경할 수 있습니다.)
  - PUT : 파일을 전송 (HTTP는 안전하지 않음.)
  - HEAD : 메시지 헤더 부분만을 획득
  - DELETE : 파일을 삭제 (HTTP는 안전하지 않음.)
  - CONNECT : 프록시에 터널링을 요구합니다.

- HTTP의 `지속 연결(Persistent Connections)`은 하나의 HTML 문서에 여러 개의 이미지 등이 포함된 경우, 여러 번의 TCP Connection이 발생한다는 단점을 보완하기 위해 만들어졌습니다. 지속연결은 1회의 TCP 커넥션 연결로 리퀘스트와 리스폰스를 여러 번 교환합니다. 이 동작은 HTTP/1.1의 표준 동작으로 채택되었습니다.

- 지속 연결은 `파이프 라인(HTTP Pipelining)` 기능을 제공합니다. 파이프라인은 이전 리퀘스트에 대한 응답을 받지 못했음에도 연속적으로 리퀘스트를 전달할 수 있는 기법을 의미합니다. (TCP Sliding Window)

<hr>

## [3장. HTTP 정보는 HTTP 메세지에 있다.]

- HTTP 메시지는 크게 `메시지 헤더`와 `메시지 바디` 영역으로 나뉩니다. 이 둘 사이에는 `개행문자(CR+LF)`가 포함되어있어, 개행문자로 두 영역을 구분합니다. (메시지 바디 부분은 리퀘스트에 따라 없을 수도 있습니다.)

- HTTP는 전송할 때에 인코딩을 수행하여 전송 효율을 높일 수 있습니다. 대신 인코딩 작업은 CPU를 사용하기 때문에 리소스의 사용은 높아집니다.

- HTTP는 용량이 큰 파일을 압축해서 보내는 `컨텐츠 코딩(Content Codings)` 기능이 있습니다. 이 기능은 엔티티에 인코딩을 적용하는 기법입니다.

  - 대표적으로는 `gzip(GNU zip)`, `compress(UNIX Standard)` 등이 있습니다.

- HTTP는 사이즈가 큰 파일을 분할해서 전송하는 `청크 전송 코딩(Chunked Transfer Coding)` 기능이 있습니다.

  - 네이버 홈을 들어갔을 때, 이미지 파일을 완전히 받아오지 않아도 브라우저가 화면에 표시될 수 있도록 해줍니다.

- HTTP는 `멀티 파트`에도 대응하고 있어 메시지 바디 내부에 엔티티를 여러 개 포함시켜 전송할 수 있습니다. 주로 이미지나 텍스트 파일 등을 업로드할 때 사용되고 있습니다.

  - 헤더의 Content-Type은 `multipart/form-data` 또는 `multipart/byteranges`를 사용하며, 각 엔티티는 `boundary`라는 값을 경계로 구분짓습니다.

- HTTP는 범위를 지정하여 파일의 일부만을 요청하고, 전송받는 `레인지 리퀘스트(Range Request)` 기능이 있습니다.

  - 이 기법은 대용량의 파일을 다운로드 하다 커넥션이 끊어지는 경우, 중간부터 받을 수 있는 리줌(Resume) 기능을 제공합니다.
  - `Range Request`의 리스폰스는 상태코드 `206 Partial Content`로 응답합니다. 서버가 레인지 리퀘스트를 지원하지 않는 경우에는 `200 OK`로 응답합니다.

- 클라이언트의 언어에 맞춰 컨텐츠를 제공하는 기능을 `콘텐츠 네고시에이션(Content Negotiation)`이라고 부릅니다. 컨텐츠 네고시에이션은 리퀘스트의 `언어`, `문자세트`, `인코딩` 등으로 판단합니다.
  - 서버 구동형 네고시에이션 : 서버 측에서 콘텐츠 네고시에이션을 수행합니다. 주로 리퀘스트의 헤더 정보를 참고.
  - 에이전트 구동형 네고시에이션 : 클라이언트 측에서 수동으로 언어를 선택합니다.
  - 트랜스페이런트(투명한) 네고시에이션 : 서버와 클라이언트 각각 네고시에이션을 수행합니다.

<hr>

## [4장. 결과를 전달하는 HTTP 상태 코드]

- 서버는 리퀘스트를 어떻게 처리했는 지에 대한 정보를 상태코드에 담아 전송합니다. 상태코드는 40종류가 넘게 있지만, 자주 사용되는 상태 코드정도 14개 정도만 기억해두면 됩니다.

- 2xx : 성공을 의미하는 상태코드

  - 200 Ok : 정상적으로 처리되었음을 의미합니다.
  - 204 No content : 서버가 요청한 내용을 정상적으로 수행했지만, `response body`에는 데이터가 없습니다.
  - 206 Partial Content : `Range Request`에 대해서 정상적으로 처리되었음을 의미합니다.

- 3xx : 리다이렉트

  - 301 Moved Permanent : 요청한 URI가 다른 URI로 변경되었음을 알리며, 변경된 URI로 redirect 합니다.
  - 302 Found : 요청한 URI가 다른 URI로 **임시** 변경되었음을 알리며, 변경된 URI로 redirect 합니다.
  - 303 See Other : POST 메서드를 처리한 후, 별도의 URI로 GET 시키고 싶을 때 사용합니다.
  - 304 Not Modified : 액세스 권한은 있으나 조건이 안맞음을 의미합니다. 리다이렉트와 관련이 없으며, 리스폰스 바디에는 어떠한 데이터도 포함하지 않습니다.

- 4xx : 클라이언트 에러

  - 400 Bad Request : 리퀘스트가 문법적으로 잘못되었음을 의미합니다.
  - 401 Unauthorized : 송신한 리퀘스트에 HTTP 인증(Basic 인증, Digest 인증)이 필요함을 의미합니다. 이미 1번 리퀘스트가 이뤄진 경우에는 실패했음을 표시합니다.
  - 403 Forbidden : 액세스 권한이 없는 요청하여 요청이 거부되었음을 의미합니다. 이유를 명시하고자 하는 경우, 엔티티 바디에 기재합니다.
  - 404 Not Found : 찾고자하는 리소스가 서버에 존재하지 않음을 의미하빈다. 리퀘스트를 거부하고자 할때도 이 상태코드를 사용할 수 있습니다.

- 5xx : 서버 에러
  - 500 Internal Server Error : 서버에서 리퀘스트를 처리하는 도중에 에러가 발생했음을 의미합니다.
  - 503 Service Unavailable : 서버가 과부하 상태이거나 점검중이므로 리퀘스트를 처리하지 못함을 의미합니다.

<hr>

## [5장. HTTP와 연계하는 웹 서버]

- HTTP/1.1에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있습니다. 예를 들어, 웹 호스팅을 제공하고 있는 사업자는 1대의 서버에 여러 고객의 웹 사이트를 넣을 수 있습니다. 이러한 기능을 `가상 호스트(Virtual Host)`라고 부릅니다. HTTP 서버에는 이렇게 가상호스트가 존재할 수 있기 때문에 리퀘스트에 `Host/Domain`을 명확히 하여야 합니다.

- 프록시 서버는 클라이언트와 서버의 중간에 위치하여 클라이언트의 리퀘스트를 서버에 전송하고, 서버로부터 받은 리스폰스를 클라이언트에게 전달하는 기능을 합니다. 프록시 서버는 특정 URI에 대해 액세스를 거부하거나(사내 정보 유출 방지), 액세스 로그 획득 등을 목적으로 사용할 수 있습니다.

- `캐싱 프록시`는 서버의 리소스 캐시를 저장해두고, 클라이언트의 요청이 들어오면 서버에 리퀘스트를 전달하지 않고 캐시를 클라이언트에게 전달하는 서버 입니다. 이렇게 함으로써 오리진 서버의 부하를 줄일 수 있습니다. 클라이언트의 요청이나, 캐시가 오래되었다고 판단되는 경우 프록시 서버는 오리진 서버에 요청해 새로운 리소스를 받아옵니다.

- `게이트웨이`는 다른 서버를 중계하는 서버로, 클라이언트로부터 수신한 리퀘스트에 대한 리소스를 보유한 것처럼 행동합니다. 프록시와 유사하지만, 게이트웨이는 오리진 서버와 HTTP 프로토콜 이외의 통신을 합니다. 클라이언트와 게이트웨이 사이를 암호화하는 등으로 안전하게 접속함으로써 통신의 안전성을 높이는 역할도 합니다.

  - 예를 들어, 데이터베이스에 접속해 SQL 쿼리를 사용해서 데이터를 얻을 때 사용할 수 있습니다.
  - 쇼핑 사이트 등에서 신용카드 결제 시스템 등과 연계할 때 사용할 수도 있습니다.

- `리소스 캐시`는 캐싱 프록시만 가지고 있는 것이 아닙니다. 클라이언트의 브라우저도 `리소스 캐시`를 저장하는데 이를 `임시 파일`이라고 부릅니다. 만약, 브라우저가 유효한 캐시를 가지고 있는 경우 서버에 액세스 하지 않고, 해당 페이지를 로컬 디스크에서 불러옵니다. 만약, 리소스가 오래된 것이라고 판단되는 경우 오리진 서버에 새로운 리소스를 요청합니다.
